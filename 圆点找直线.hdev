<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,1]" as_ord="1">read_image (Image, '7.bmp')</l>
<l>get_image_size (Image, Width, Height)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, Height,Width)</l>
<l>gray_histo (Rectangle, Image, AbsoluteHisto, RelativeHisto)</l>
<l>histo_to_thresh (AbsoluteHisto, 16, MinThresh, MaxThresh)</l>
<l>threshold (Image, Region, MinThresh, MaxThresh)</l>
<l>connection (Region, ConnectedRegions)</l>
<l>count_obj (ConnectedRegions, Number1)</l>
<l>select_shape_std (ConnectedRegions, SelectedRegions1, 'max_area', 70)</l>
<c>*选择黑色 还是 白色</c>
<l>intensity (SelectedRegions1, Image, Mean, Deviation)</l>
<c></c>
<l>difference (Image, SelectedRegions1, RegionDifference)</l>
<c></c>
<l>*select_obj (ConnectedRegions, ObjectSelected, 1)</l>
<l>intensity (RegionDifference, Image, Mean1, Deviation1)</l>
<l>if(Mean1 &lt; Mean)</l>
<l>    RegionDifference := SelectedRegions1</l>
<l>endif</l>
<c></c>
<l>connection (RegionDifference, ConnectedRegions1)</l>
<l>fill_up (ConnectedRegions1, RegionFillUp)</l>
<c></c>
<l>area_center (RegionFillUp, Area3, Row5, Column5)</l>
<l>tuple_mean (Area3, Mean2)</l>
<l>select_shape (RegionFillUp, SelectedRegions3, 'area', 'and', Mean2, 9999999)</l>
<c>*获取一个最大的区域</c>
<l>select_shape_std (SelectedRegions3, SelectedRegions4, 'max_area', 70)</l>
<l>area_center (SelectedRegions4, Area5, Row8, Column8)</l>
<c></c>
<c>*提取圆相似度</c>
<l>region_features (SelectedRegions3, 'circularity', Value1)</l>
<l>tuple_mean (Value1, Mean3)</l>
<c>*提取方行相似度</c>
<l>region_features (SelectedRegions3, 'rectangularity', Value2)</l>
<l>tuple_mean (Value2, Mean4)</l>
<c></c>
<c>*判断是圆行还是方型</c>
<c>*ShapeFlag=1是圆  ShapeFlag=0是方</c>
<l>if(Mean3 &gt; Mean4)</l>
<l>    ShapeFlag := 1</l>
<l>else</l>
<l>    ShapeFlag := 0</l>
<l>endif</l>
<c></c>
<l>stop ()</l>
<c></c>
<l>mRegionWidth := []</l>
<l>if(ShapeFlag == 1)</l>
<l>    closing_circle (RegionFillUp, RegionClosing, 0.5)</l>
<l>    shape_trans (RegionClosing, RegionTrans, 'outer_circle')</l>
<l>    smallest_circle (SelectedRegions4, Row6, Column6, Radius2) </l>
<c>    *获取区域的宽度</c>
<l>    mRegionWidth := Radius2 *2  </l>
<l>else</l>
<l>    closing_rectangle1 (RegionFillUp, RegionClosing2,0.5, 0.5)</l>
<l>    shape_trans (RegionClosing2, RegionTrans, 'rectangle1')</l>
<l>    smallest_rectangle1 (SelectedRegions4, Row12, Column12, Row21, Column21)</l>
<c>    *获取区域的宽度</c>
<l>    mRegionWidth := Row21 - Row12</l>
<l>endif</l>
<c></c>
<c></c>
<c></c>
<l>select_shape (RegionTrans, SelectedRegions, 'area', 'and', Mean2, 9999999)</l>
<l>gen_contour_region_xld (SelectedRegions, Contours, 'border')</l>
<l>*gen_region_contour_xld (Contours, Region1, 'filled')</l>
<c></c>
<c></c>
<l>area_center (RegionTrans, Area, Row, Column)</l>
<c></c>
<l>area_center_xld (Contours, Area1, Row3, Column3, PointOrder)</l>
<c></c>
<l>tuple_length (Column3, Length)</l>
<c>*算出每个圆点和视野中心点的距离300 *300</c>
<l>for Index := 0 to Length -1 by 1</l>
<c></c>
<l>distance_pp (Height/2, Width/2, Row3[Index], Column3[Index], Distance)</l>
<l>NewDistance[Index] := Distance</l>
<c></c>
<l>endfor</l>
<c></c>
<l>stop ()</l>
<c>*找出距离视野中心点最近的圆点</c>
<l>tuple_min (NewDistance, Min)</l>
<l>tuple_find (NewDistance, Min, Indices)</l>
<l>*gen_region_line (RegionLines, RowBegin, RowEnd,ColBegin, ColEnd)</l>
<l>stop()</l>
<l>dev_clear_window ()</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('red')</l>
<c>*考虑显示出来  显示所有的圆点</c>
<l>gen_cross_contour_xld (Cross, Row3, Column3, 15, 0.785398)</l>
<c></c>
<l>dev_set_color ('green')</l>
<c></c>
<c>*保存距离中点最近的坐标</c>
<l>CenterR := Row3[Indices]</l>
<l>CenterC := Column3[Indices]</l>
<c></c>
<l>tuple_remove (Row3, Indices, Row3)</l>
<l>tuple_remove (Column3, Indices, Column3)</l>
<c></c>
<l>dev_set_color ('black')</l>
<l>gen_cross_contour_xld (Cross2, CenterR, CenterC, 30, 90)</l>
<l>stop ()</l>
<c></c>
<l>NewCrossROW := 0</l>
<l>NewCrossCOL := 0</l>
<c></c>
<l>dev_set_color ('green')</l>
<c>*算出离中心点最近的四个坐标</c>
<l>for Index2 := 0 to 4-1 by 1</l>
<l>tuple_length (Row3, Length1)</l>
<c></c>
<l>    for Index := 0 to Length1 -1 by 1</l>
<l>    distance_pp (CenterR, CenterC, Row3[Index], Column3[Index], Distance)</l>
<l>    NewDistance[Index] := Distance</l>
<l>    endfor</l>
<l>stop ()</l>
<l>tuple_min (NewDistance, Min1)</l>
<l>tuple_find (NewDistance, Min1, Indices2)</l>
<l>*gen_cross_contour_xld (Cross3, Row3[Indices2[0]], Column3[Indices2[0]], 30, 60)</l>
<c>*NewCrossROW 可以作为间距使用</c>
<l>NewCrossROW[Index2] := Row3[Indices2[0]]</l>
<l>NewCrossCOL[Index2] := Column3[Indices2[0]]</l>
<l>tuple_remove (Row3, Indices2[0], Row3)</l>
<l>tuple_remove (Column3, Indices2[0], Column3)</l>
<l>tuple_remove (NewDistance, Indices2[0], NewDistance)</l>
<l>Length1 := Length1 - 1</l>
<c></c>
<c></c>
<l>endfor</l>
<c></c>
<c>*算出间距（步距）</c>
<l>tuple_length (NewCrossROW, Length3)</l>
<l>if(Length3 != 4)</l>
<c>    *做判断</c>
<l>endif</l>
<c></c>
<l>for Index4 := 0 to Length3-1 by 1</l>
<l>    mDisRow[Index4] := NewCrossROW[Index4] -CenterR</l>
<l>endfor</l>
<c></c>
<l>tuple_abs (mDisRow, Abs2)</l>
<l>tuple_max (Abs2, mDIsRMax)</l>
<c></c>
<c></c>
<l>gen_cross_contour_xld (Cross3, NewCrossROW, NewCrossCOL, 30, 60)</l>
<c></c>
<l>stop ()</l>
<c>*查找出的4个点和中心点连成直线，计算出最小的角度</c>
<l>gen_empty_obj (EmptyObject)</l>
<l>MinDug := [ ]</l>
<l>for Index1 := 0 to 4-1 by 1</l>
<l>gen_region_line (RegionLines3, NewCrossROW[Index1], NewCrossCOL[Index1], CenterR, CenterC)</l>
<l>concat_obj (EmptyObject, RegionLines3, EmptyObject)</l>
<l>count_obj (EmptyObject, Number)</l>
<l>select_obj (EmptyObject, ObjectSelected1, Index1+1)</l>
<l>region_features (ObjectSelected1, 'phi', Value)</l>
<l>tuple_deg (Value, Deg2)</l>
<c></c>
<l>MinDug := [MinDug,Deg2]</l>
<c></c>
<l>endfor</l>
<c></c>
<c>*算出最小的角度，取原始的正负角度</c>
<l>tuple_abs (MinDug, Abs)</l>
<l>tuple_min (Abs, Min2)</l>
<c></c>
<l>for Index3 := 0 to 4-1 by 1</l>
<l>    tuple_abs (MinDug[Index3], Abs1)</l>
<l>    if(Abs1 == Min2)</l>
<l>        MinDeg := MinDug[Index3]</l>
<l>    endif</l>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<c></c>
<l>stop ()</l>
<l>* gen_contour_polygon_xld (Contour, NewCrossROW, NewCrossCOL)</l>
<l>* fit_line_contour_xld (Contour, 'tukey', -1, 0, 5, 2, RowBegin1, ColBegin1, RowEnd1, ColEnd1, Nr, Nc, Dist)</l>
<c></c>
<l>* gen_region_line (RegionLines1, RowBegin1, ColBegin1, RowEnd1, ColEnd1)</l>
<l>* line_orientation (RowBegin1, ColBegin1, RowEnd1, ColEnd1, Phi)</l>
<l>* region_features (RegionLines1, 'phi', Value)</l>
<c></c>
<l>* tuple_deg (Value, Deg)</l>
<c></c>
<l>stop ()</l>
<c></c>
<c>*下面部分可以做细调整</c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -rad(MinDeg), Width, Height, HomMat2DRotate)</l>
<c></c>
<l>stop ()</l>
<l>affine_trans_image (Image, ImageAffinTrans, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
<c></c>
<c>*细调整 自动识别调整</c>
<l>dev_display (ImageAffinTrans)</l>
<l>*draw_rectangle1 (3600, Row11, Column11, Row2, Column2)</l>
<l>*gen_rectangle1 (ROI_0, Row11, Column11, Row2, Column2)</l>
<c></c>
<l>*reduce_domain (ImageAffinTrans, ROI_0, ImageReduced)</l>
<l>*threshold (ImageReduced, Regions, 208, 255)</l>
<l>binary_threshold (ImageAffinTrans, Region2, 'max_separability', 'light', UsedThreshold)</l>
<c></c>
<l>fill_up (Region2, RegionFillUp2)</l>
<l>connection (RegionFillUp2, RegionFillUp2)</l>
<c></c>
<c></c>
<l>select_shape (RegionFillUp2, SelectedRegions2, 'area', 'and', Mean2, 9999999)</l>
<c></c>
<l>select_shape (SelectedRegions2, SelectedRegions5, ['column','row'], 'and', [250,250], [350,350])</l>
<l>select_obj (SelectedRegions5, ObjectSelected2, 1)</l>
<l>area_center (ObjectSelected2, Area4, Row7, Column7)</l>
<c></c>
<l>gen_rectangle1 (Rectangle3, Row7-mRegionWidth/2*1.3, 0, Row7+mRegionWidth/2*1.3, 600)</l>
<l>reduce_domain (ImageAffinTrans, Rectangle3, ImageReduced1)</l>
<l>binary_threshold (ImageReduced1, Region3, 'max_separability', 'light', UsedThreshold1)</l>
<c></c>
<l>connection (Region3, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions6, 'area', 'and', Area5*0.8, 99999)</l>
<c></c>
<l>count_obj (SelectedRegions6, Number2)</l>
<l>if(ShapeFlag == 1)</l>
<l>    closing_circle (SelectedRegions6, RegionClosing1, 0.5)</l>
<l>    fill_up (RegionClosing1, RegionFillUp1)</l>
<l>    shape_trans (RegionFillUp1, RegionTrans1, 'outer_circle')</l>
<l>else</l>
<l>    closing_rectangle1 (SelectedRegions6, RegionClosing1, 1, 1)</l>
<l>     fill_up (RegionClosing1, RegionFillUp1)</l>
<l>    shape_trans (RegionFillUp1, RegionTrans1, 'rectangle1')</l>
<l>endif</l>
<c></c>
<l>sort_region (SelectedRegions6, SortedRegions, 'first_point', 'true', 'column')</l>
<l>area_center (SortedRegions, Area2, Row1, Column1)</l>
<c></c>
<l>smallest_circle (Region3, Row4, Column4, Radius1)</l>
<l>*Radius:=sqrt(Area2[0]/3.1415926)</l>
<l>*Radius := Radius / 2</l>
<c></c>
<l>*gen_rectangle1 (Rectangle1, Row1[0]-Radius1[0], 0, Row1[0]+Radius1[0], 200)</l>
<c></c>
<l>*gen_rectangle1 (Rectangle2, Row1[0]-Radius1[0]-mDIsRMax, 0, Row1[0]+Radius1[0]-mDIsRMax, 1500)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageAffinTrans)</l>
<l>stop ()</l>
<l>gen_cross_contour_xld (Cross1, Row1, Column1, 60, 0.785398)</l>
<c></c>
<l>gen_empty_obj (mRegionLines)</l>
<c></c>
<l>for Index5 := 0 to Number2-2 by 1</l>
<l>    gen_region_line (RegionLines3, Row1[Index5], Column1[Index5], Row1[Index5+1], Column1[Index5+1])</l>
<c> </c>
<l>    concat_obj (RegionLines3, mRegionLines, mRegionLines)</l>
<l>endfor</l>
<l>count_obj (mRegionLines, Number3)</l>
<c></c>
<l>elliptic_axis (mRegionLines, Ra1, Rb1, Phi2)</l>
<l>*elliptic_axis (RegionLines2, Ra, Rb, Phi1)</l>
<l>tuple_deg (Phi2, Deg1)</l>
<l>tuple_mean (Deg1, Mean5)</l>
<c></c>
<c></c>
<l>stop ()</l>
<c></c>
<c></c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>hom_mat2d_rotate (HomMat2DIdentity, -rad(Mean5), Width, Height, HomMat2DRotate)</l>
<c></c>
<c></c>
<l>affine_trans_image (ImageAffinTrans, ImageAffinTrans, HomMat2DRotate, 'constant', 'false')</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
